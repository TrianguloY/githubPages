<!DOCTYPE html>
<html>

<head>
    <script src="https://unpkg.com/konva@9.3.11/konva.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
    <meta charset="utf-8" />
    <title>Petr</title>
    <style>
        body {
          margin: 0;
          padding: 0;
          overflow: hidden;
          background-color: #121212;
        }
        span, details {
          color: white;
        }
        .draggable {
          background-color: gray;
          margin: 5px;
        }
        header {
          position: fixed;
          top: 10px;
          left: 10px;
        }
    </style>
</head>
<!-- WIP -->

<body>
    <div id="container"></div>
    <header>
        <input id="element_n" type='number' value="4" min="0" onchange="draw1();" />
        <span>
          Angles: <span style="color: red">O &gt;</span>
          <span id="element_angles"></span>
          &gt; O
        </span>
        <details>
          <summary>ℹ️</summary>
          <p>
          Made by TrianguloY
          </p>
        </details>

    </header>
    <script>
        let n;
        let points = [];

        function draw1() {
          n = element_n.value;

          clearDraggablePoints();
          while(points.length > n) points.pop();
          while(points.length < n) points.push([Math.random() * window.innerWidth, Math.random() * window.innerHeight]);
          // points = range(0, n, () => [Math.random() * window.innerWidth, Math.random() * window.innerHeight]);
          console.log("points", points);
          points.forEach(([x, y], i) => drawDraggablePoint(x, y, (nx, ny) => {
            points[i] = [nx, ny];
            draw3();
          }));

          draw2();
        }

        function draw2() {
          let angles = range(1, n - 0, i => 360 * i / n);

          element_angles.innerHTML = angles.map(a=>`<span class="draggable" style="color: ${color(a)}" data-angle="${a}">&gt; ${a.toFixed(2)}º &gt;</span>`).join("");
          console.log("angles", angles);

          draw3();
        }

        function draw3() {
          clearPolygons();
          drawPolygon(points, color(0));

          let angles = [...element_angles.querySelectorAll("span[data-angle]")].map(e=>e.dataset.angle);

          let nextPoints = points;
          angles.forEach(angle => {
            let newpoints = [];
            for (let i = 0; i < n; ++i) {
              newpoints.push(calculatePoint(nextPoints[i], nextPoints[(i + 1) % n], angle))
              drawAngle(nextPoints[i], newpoints[i], nextPoints[(i + 1) % n], color(angle, 0.1));//'#4444'
            }
            console.log("newpoints", newpoints);
            drawPolygon(newpoints, color(angle));
            nextPoints = newpoints;
          });
        }

        //----- utils -------

        function calculatePoint([x1, y1], [x2, y2], angle) {
          // given two points A, B and an angle c, returns the coordinates of the point C (for a triangle ABC isosceles with AC=BC)
          let t = Math.tan(angle / 2 * Math.PI / 180);
          return [
            (x1 + x2) / 2 + (y1 - y2) / 2 / t,
            (y1 + y2) / 2 + (x2 - x1) / 2 / t,
          ];
        }

        function color(angle, alpha=1) {
          let c = Konva.Util.colorToRGBA(`hsl(${Math.round(angle)},100%,50%)`);
          return `rgba(${c.r},${c.g},${c.b},${alpha})`;
        }

        function range(start, end, mapper) {
          let v = [];
          for (let i = start; i < end; ++i) v.push(mapper(i));
          return v;
        }

        function length([x1, y1], [x2, y2]) {
          return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
        }


        //------ Konva -----

        let stage;
        let pointsLayer;
        let polygonsLayer;

        function initCanvas() {

          stage = new Konva.Stage({
            container: 'container',
            width: window.innerWidth,
            height: window.innerHeight,
            draggable: true,
          });

          polygonsLayer = new Konva.Layer();
          stage.add(polygonsLayer);

          pointsLayer = new Konva.Layer();
          stage.add(pointsLayer);


          // zoom
          var scaleBy = 2;
          stage.on('wheel', e => {
            // stop default scrolling
            e.evt.preventDefault();

            var oldScale = stage.scaleX();
            var pointer = stage.getPointerPosition();

            // how to scale? Zoom in? Or zoom out?
            let direction = e.evt.deltaY > 0 ? -1 : 1;

            // when we zoom on trackpad, e.evt.ctrlKey is true
            // in that case lets revert direction
            if (e.evt.ctrlKey) direction = -direction;

            var newScale = direction > 0 ? oldScale * scaleBy : oldScale / scaleBy;

            stage.scale({
              x: newScale,
              y: newScale
            });

            var mousePointTo = {
              x: (pointer.x - stage.x()) / oldScale,
              y: (pointer.y - stage.y()) / oldScale,
            };

            stage.position({
              x: pointer.x - mousePointTo.x * newScale,
              y: pointer.y - mousePointTo.y * newScale,
            });
          });

        }

        function clearDraggablePoints() {
          pointsLayer.destroyChildren();
        }

        function clearPolygons() {
          polygonsLayer.destroyChildren();
        }

        function drawDraggablePoint(x, y, ondrag) {
          let visualPoint = new Konva.Circle({
            x: x,
            y: y,
            radius: 5,
            fill: 'white'
          });
          pointsLayer.add(visualPoint);

          let draggablePoint = new Konva.Circle({
            x: x,
            y: y,
            radius: 20,
            draggable: true,
          });
          draggablePoint.on('dragmove', () => {
            visualPoint.x(draggablePoint.x());
            visualPoint.y(draggablePoint.y());
            ondrag(draggablePoint.x(), draggablePoint.y());
          });
          pointsLayer.add(draggablePoint);
        }

        function drawAngle(firstPoint, middlePoint, lastPoint, color) {
          polygonsLayer.add(new Konva.Line({
            points: [firstPoint, middlePoint, lastPoint].flatMap(e => e),
            stroke: color,
            strokeWidth: 1,
            closed: false,
            strokeScaleEnabled: false,
            lineJoin: "round",
            lineCap: "round"
          }));

          let startAngle = Math.atan2(firstPoint[1] - middlePoint[1], firstPoint[0] - middlePoint[0]) / Math.PI * 180;
          let endAngle = Math.atan2(lastPoint[1] - middlePoint[1], lastPoint[0] - middlePoint[0]) / Math.PI * 180;
          let dist = Math.min(length(firstPoint, middlePoint), length(firstPoint, lastPoint)) / 10;

          polygonsLayer.add(new Konva.Arc({
            x: middlePoint[0],
            y: middlePoint[1],
            innerRadius: 0,
            outerRadius: dist,
            fill: color,
            angle: endAngle - startAngle,
            rotation: startAngle,
          }));
        }


        function drawPolygon(points, color) {

          let [Mx, My, mx, my] = points.reduce(([Mx, My, mx, my], [x, y]) => [Math.max(x, Mx), Math.max(y, My), Math.min(x, mx), Math.min(y, my)], [-Infinity, -Infinity, Infinity, Infinity]);
          console.log([Mx, My, mx, my])
          if (Math.abs(Mx - mx) < 1 / 100 && Math.abs(My - my) < 1 / 100) {
            polygonsLayer.add(new Konva.Circle({
              x: Mx,
              y: My,
              radius: 2,
              fill: color,
            }));
          } else {

            polygonsLayer.add(new Konva.Line({
              points: points.flatMap(e => e),
              stroke: color,
              strokeWidth: 1,
              closed: true,
              strokeScaleEnabled: false,
              lineJoin: "round",
              lineCap: "round"
            }));
          }
        }


        //------ init ------

        initCanvas();
        draw1();

        Sortable.create(element_angles, {onChange: draw3});
    </script>
</body>

</html>